# Лабораторная работа №3. Spring Security
В процессе выполнения лабораторной работы требуется ознакомиться с технологией Spring Security. Необходимо выполнить пункты 1,2,5 обязательно, и 3/4 на выбор.

1. Подключите в ваш проект зависимость Spring Security.
2. Сконфигурируйте Security следующим образом: все запросы, изменяющие проекты (**а не задачи**), должны быть доступны только администратору. Остальные запросы доступны и пользователям, и администраторам. Незалогиненный пользователь не может получать никакую информацию.
3. Пользователи конфигурируются посредством [InMemoryUserDetailsManager](https://docs.spring.io/spring-security/site/docs/4.2.x/apidocs/org/springframework/security/provisioning/InMemoryUserDetailsManager.html). 
   Сочетания login/password/role должны считываться из application.properties файла.
   ```
   security.logins=just_user,superadmin
   security.passwords=1234,admin1234
   security.roles=USER,ADMIN
   ```
4. 
   Создайте в базе данных таблицу пользователей со следующими полями:
   - `id` - `bigserial`
   - `login` - `text`
   - `password` - `text`
   - `enabled` - `boolean`

   Создайте таблицу ролей:
   - `id` - `bigserial`
   - `name` - `text`
   
   Добавьте many-to-many таблицу пользователи-роли.

   Создайте Entity классы для описания таблиц пользователей, ролей. Entity-класс пользователя должен реализовывать `UserDetails` интерфейс.

   Создайте JPA интерфейс `UserRepository` для работы с сущностью `User`.

   Создайте класс `UserDetailsServiceImpl`, реализующий интерфейс `UserDetailsService`. Реализуйте метод `loadUserByUsername`.

   Добавьте в конфигурационный компонент объявление следующего бина:
   ```java
   @Bean
   public AuthenticationManager authenticationManager() {
       DaoAuthenticationProvider authenticationProvider = new DaoAuthenticationProvider();
       authenticationProvider.setUserDetailsService(userDetailsService);
       authenticationProvider.setPasswordEncoder(passwordEncoder());
   
       return authenticationProvider;
   }
5. После успешного логина необходимо перенаправлять на `/projects`.

## Задание на бесконечное уважение
### Реализация токена в Spring Boot  

#### *Генерация и сохранение ключа*  
1. Сгенерируйте секретный ключ для подписи токена.  
2. Сохраните ключ в переменную среды для последующего использования.  

#### *Формирование токена*  
3. Проверьте, что пользователь действительно зарегистрирован в системе.  
4. Создайте **два токена**:  
   - *Access Token* (основной токен) со следующими полями:  
     - `userId` — идентификатор пользователя,  
     - `roles` — список ролей пользователя,  
     - `iat` — время создания токена,  
     - `exp` — время истечения токена (например, 15 минут).  
   - *Refresh Token* (токен для обновления), содержащий:  
     - `userId`,  
     - `exp` (время истечения, например, 7 дней).  
5. Преобразуйте payload в JSON.  Закодируйте в base64
6. Подпишите токены, используя ключ и алгоритм *HS256*.  
7. Соберите итоговый токен в формате:  
   
   <полезная_нагрузка>.<подпись>
   
8. Реализуйте генерацию *вручную*, без сторонних библиотек (кроме сериализации в JSON и HMAC-SHA256 для подписи).  

#### *Проверка токена*  
9. При каждом запросе:  
   - Извлекайте Access Token,  
   - Проверяйте подпись,  
   - Проверяйте `exp` (не истёк ли токен),  
   - Если подпись или срок действия неверны — *отклоните запрос*.  
10. Реализуйте проверку токена через *фильтр Spring Security*, за исключением эндпоинтов `/login` и `/refresh`.  

#### *Обработка ошибок*  
11. При невалидном токене (неправильная подпись, истёк срок) отправляйте *HTTP 401 Unauthorized* с причиной ошибки.  
12. Если токен отсутствует — отправляйте *HTTP 403 Forbidden*.  

#### *Обновление токена (Refresh Token)*  
13. Реализуйте эндпоинт `/refresh`, который:  
   - Принимает *Refresh Token*,  
   - Проверяет его подпись и срок действия,  
   - Генерирует *новый Access Token* без запроса логина/пароля.  
14. Если Refresh Token недействителен — *запросить повторный логин* (удалять его со стороны сервера).  
